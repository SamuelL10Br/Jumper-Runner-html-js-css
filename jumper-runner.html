<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jumping Ball Runner</title>
  <style>
    :root{
      --bg0:#86e8ff; /* sky */
      --bg1:#c6f1ff; /* horizon haze */
      --ground1:#6be36b; /* grass */
      --ground2:#46b946; /* darker grass */
      --ui:#1f2937; /* slate-800 */
      --ui2:#334155; /* slate-700 */
      --accent:#ff3ea5; /* fun pink */
      --accent2:#ffc23e; /* sunny yellow */
      --white:#ffffff;
    }
    html,body{
      height:100%;margin:0;overflow:hidden;background:linear-gradient(#7ed8ff,#d7f6ff);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji";
      user-select:none;
      color:var(--white);
    }
    #game{
      position:fixed;inset:0;display:grid;place-items:center;
      background: linear-gradient(180deg, var(--bg0) 0%, var(--bg1) 70%);
    }
    canvas{display:block; width:100vw; height:100vh; image-rendering: optimizeSpeed;}
    .hud{
      position:fixed; inset:0; pointer-events:none; padding:16px; display:flex; justify-content:space-between; align-items:flex-start; font-weight:700; text-shadow:0 2px 0 rgba(0,0,0,.25);
    }
    .chip{ pointer-events:auto; background:rgba(31,41,55,.55); border:2px solid rgba(255,255,255,.25); backdrop-filter: blur(6px); padding:8px 12px; border-radius:999px; box-shadow:0 6px 16px rgba(0,0,0,.2);
    }
    .btn{
      pointer-events:auto; background:linear-gradient(180deg, var(--accent) 0%, #ff5ec2 100%); border:none; color:#fff; font-weight:900; letter-spacing:.5px;
      border-radius:16px; padding:12px 18px; box-shadow: 0 10px 0 #b81f79, 0 16px 24px rgba(0,0,0,.25);
      transform: translateY(0); transition: transform .08s ease, box-shadow .08s ease, filter .2s; cursor:pointer;
    }
    .btn:hover{ filter:brightness(1.05); }
    .btn:active{ transform: translateY(6px); box-shadow: 0 4px 0 #b81f79, 0 8px 14px rgba(0,0,0,.25); }
    .btn.secondary{ background:linear-gradient(180deg, var(--accent2) 0%, #ff9f1c 100%); box-shadow:0 10px 0 #b57907, 0 16px 24px rgba(0,0,0,.25);}
    .brand{ position:fixed; left:50%; transform:translateX(-50%); top:14px; pointer-events:none; font-weight:900; letter-spacing:.5px; color:#0b2038; text-shadow:0 2px 0 rgba(255,255,255,.6), 0 6px 24px rgba(0,0,0,.25);}

    .center-ui{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; }
    .card{ pointer-events:auto; text-align:center; background: rgba(255,255,255,.8); color:#0b2038; border:4px solid #0b2038; border-radius:24px; padding:24px 20px; width:min(92vw, 520px); box-shadow: 0 24px 80px rgba(0,0,0,.3);}
    .title{ font-size: clamp(28px, 5vw, 44px); font-weight:900; margin:0 0 8px; color:#0b2038; }
    .subtitle{ margin:0 0 16px; font-size: clamp(14px, 2.6vw, 18px); opacity:.9; }
    .row{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }

    .hidden{ display:none !important; }
    .toast{ position:fixed; bottom:14px; left:50%; transform:translateX(-50%); background:rgba(31,41,55,.85); border:1px solid rgba(255,255,255,.2); padding:8px 12px; border-radius:999px; font-size:14px; pointer-events:none; }
    .sound-toggle{ position:fixed; right:16px; bottom:16px; }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="c" width="1280" height="720" aria-label="Jumping Ball Runner"></canvas>
  </div>
  <div class="hud">
    <div class="chip" id="score">Score: 0</div>
    <div class="chip" id="high">Best: 0</div>
  </div>
  <div class="brand">🎈 JUMPING BALL RUNNER</div>

  <div class="center-ui" id="startScreen">
    <div class="card">
      <div class="title">🎈 Jumping Ball Runner</div>
      <p class="subtitle">Jump over silly obstacles and survive as long as you can!<br>Press <b>Space</b> / <b>Tap</b> / <b>Click</b> to JUMP.</p>
      <div class="row">
        <button class="btn" id="playBtn">Play</button>
        <button class="btn secondary" id="howBtn">How to Play</button>
      </div>
    </div>
  </div>

  <div class="center-ui hidden" id="howScreen">
    <div class="card">
      <div class="title">How to Play</div>
      <p class="subtitle" style="text-align:left">
        • Jump over obstacles to stay alive.<br>
        • Speed increases over time (brace yourself).<br>
        • Each obstacle dodged = +1 point.<br>
        • Beat your <b>Best</b> score and brag endlessly.<br>
        • Press <b>R</b> or hit <b>Retry</b> after a crash.
      </p>
      <div class="row">
        <button class="btn" id="backBtn">Back</button>
      </div>
    </div>
  </div>

  <div class="center-ui hidden" id="gameOver">
    <div class="card">
      <div class="title">💥 Ouch! Game Over</div>
      <p class="subtitle" id="finalText">You did great!</p>
      <div class="row">
        <button class="btn" id="retryBtn">Retry</button>
        <button class="btn secondary" id="menuBtn">Main Menu</button>
      </div>
    </div>
  </div>

  <div class="toast hidden" id="toast">Nice jump!</div>
  <button class="btn sound-toggle" id="soundBtn" title="Toggle sound">🔊</button>

  <script>
  (()=>{
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // Responsive canvas
    function fit(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const w = window.innerWidth, h = window.innerHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }
    fit();
    window.addEventListener('resize', fit);

    // ---- UI Elements ----
    const startScreen = document.getElementById('startScreen');
    const howScreen = document.getElementById('howScreen');
    const gameOver = document.getElementById('gameOver');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const finalText = document.getElementById('finalText');
    const toastEl = document.getElementById('toast');

    const playBtn = document.getElementById('playBtn');
    const howBtn = document.getElementById('howBtn');
    const backBtn = document.getElementById('backBtn');
    const retryBtn = document.getElementById('retryBtn');
    const menuBtn = document.getElementById('menuBtn');
    const soundBtn = document.getElementById('soundBtn');

    const HS_KEY = 'jbr_highscore';
    let highScore = Number(localStorage.getItem(HS_KEY)||0);
    highEl.textContent = `Best: ${highScore}`;

    // ---- Audio (procedural, tiny + funny) ----
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let actx = null; // lazily init on first user gesture
    let soundOn = true;

    function ensureAudio(){
      if(!actx){ actx = new AudioCtx(); }
    }

    function playBeep(freq=440, duration=0.12, type='sine', volume=0.2){
      if(!soundOn) return; ensureAudio();
      const t0 = actx.currentTime;
      const osc = actx.createOscillator();
      const gain = actx.createGain();
      osc.type = type; osc.frequency.value=freq;
      gain.gain.setValueAtTime(0.0001, t0);
      gain.gain.exponentialRampToValueAtTime(volume, t0+0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0+duration);
      osc.connect(gain).connect(actx.destination);
      osc.start(); osc.stop(t0+duration+0.02);
    }

    function playNoise(duration=0.2){
      if(!soundOn) return; ensureAudio();
      const bufferSize = actx.sampleRate * duration;
      const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * (1-i/bufferSize); }
      const noise = actx.createBufferSource(); noise.buffer = buffer;
      const gain = actx.createGain(); gain.gain.value = 0.35;
      const biquad = actx.createBiquadFilter(); biquad.type='highpass'; biquad.frequency.value=800;
      noise.connect(biquad).connect(gain).connect(actx.destination);
      noise.start();
    }

    const sfx = {
      jump: ()=>{ playBeep(620,0.12,'sine',0.25); setTimeout(()=>playBeep(880,0.08,'triangle',0.2),60); },
      score: ()=>{ playBeep(1040,0.06,'square',0.18); },
      hit: ()=>{ playNoise(0.25); setTimeout(()=>playBeep(120,0.2,'sawtooth',0.25),40); },
      start: ()=>{ [440,550,660].forEach((f,i)=>setTimeout(()=>playBeep(f,0.08,'triangle',0.2), i*100)); }
    };

    soundBtn.addEventListener('click', ()=>{
      soundOn = !soundOn; soundBtn.textContent = soundOn ? '🔊' : '🔈';
      if(soundOn) { try { ensureAudio(); sfx.start(); } catch(e){} }
    });

    // Helper: toast
    let toastTimer = 0;
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.remove('hidden');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.add('hidden'), 1200);
    }

    // ---- Game State ----
    let running = false, dead = false, started = false;
    const G = 0.7; // gravity
    const jumpVel = -12.5;
    let speed = 6; const baseSpeed = 6; const maxSpeed = 16; let distance=0;
    let score = 0;

    const player = { x: 140, y: 0, r: 26, vy:0, onGround:false, blink:0 };
    let groundY = 0; // set in resize

    // Obstacles
    const obs = [];
    let spawnTimer = 0;

    // Parallax layers content
    const clouds = [];
    const hills = [];
    const bushes = [];

    function reset(){
      running=false; dead=false; started=true; score=0; distance=0; speed=baseSpeed;
      player.y = 0; player.vy=0; player.onGround=false; player.blink=0;
      obs.length = 0; clouds.length=0; hills.length=0; bushes.length=0; spawnTimer=0;
      initScenery();
      updateHUD();
    }

    function updateHUD(){
      scoreEl.textContent = `Score: ${score}`;
      highEl.textContent = `Best: ${highScore}`;
    }

    // ---- Input ----
    function tryJump(){
      if(!started){ startGame(); return; }
      if(!running) return; // ignore when paused or over
      if(player.onGround){ player.vy = jumpVel; player.onGround=false; sfx.jump(); toast('Boing!'); }
    }

    window.addEventListener('keydown', (e)=>{
      if(['Space','ArrowUp','KeyW'].includes(e.code)){ e.preventDefault(); tryJump(); }
      if(e.code==='KeyR' && dead){ e.preventDefault(); startGame(); }
      if(e.code==='Enter' && !running){ e.preventDefault(); startGame(); }
    });
    window.addEventListener('pointerdown', tryJump);

    playBtn.addEventListener('click', ()=>{ startGame(); });
    howBtn.addEventListener('click', ()=>{ startScreen.classList.add('hidden'); howScreen.classList.remove('hidden'); });
    backBtn.addEventListener('click', ()=>{ howScreen.classList.add('hidden'); startScreen.classList.remove('hidden'); });
    retryBtn.addEventListener('click', ()=>{ startGame(); });
    menuBtn.addEventListener('click', ()=>{ gameOver.classList.add('hidden'); startScreen.classList.remove('hidden'); });

    function startGame(){
      ensureAudio(); sfx.start();
      startScreen.classList.add('hidden'); howScreen.classList.add('hidden'); gameOver.classList.add('hidden');
      reset(); running=true; toast('Good luck!');
    }

    // ---- Scenery Generators ----
    function initScenery(){
      const w = canvas.clientWidth; const h = canvas.clientHeight; groundY = h*0.78;
      player.y = groundY - player.r;
      for(let i=0;i<8;i++){ clouds.push({ x: Math.random()*w, y: 40+Math.random()*h*0.3, s: 0.2+Math.random()*0.6, wob: Math.random()*6.28 }); }
      for(let i=0;i<6;i++){ hills.push({ x: Math.random()*w, y: groundY-60-Math.random()*80, r: 60+Math.random()*140, s:0.5+Math.random()*0.5 }); }
      for(let i=0;i<14;i++){ bushes.push({ x: Math.random()*w, y: groundY-18, w: 40+Math.random()*50, s: 1+Math.random()*0.8 }); }
    }

    initScenery();

    // ---- Drawing helpers ----
    function drawCloud(x,y,scale){
      ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      roundedCloud();
      ctx.restore();
    }
    function roundedCloud(){
      ctx.beginPath();
      ctx.arc(0,10,24,Math.PI*0.5,Math.PI*1.5);
      ctx.arc(22,0,30,Math.PI*1,Math.PI*1.85);
      ctx.arc(50,12,22,Math.PI*1.2,Math.PI*2);
      ctx.arc(76,14,18,Math.PI*1.2,Math.PI*2);
      ctx.arc(88,10,16,Math.PI*1.5,Math.PI*0.5);
      ctx.closePath(); ctx.fill();
    }

    function drawHill(x,y,r,shade){
      const g = ctx.createLinearGradient(0,y-r,0,y+r);
      g.addColorStop(0, shade);
      g.addColorStop(1, '#2f8f2f');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x,y,r,Math.PI,0); ctx.closePath(); ctx.fill();
    }

    function drawBush(x,y,w){
      ctx.save(); ctx.translate(x,y);
      ctx.fillStyle = '#2ecc71';
      for(let i=0;i<3;i++){
        ctx.beginPath(); ctx.arc(i*18,0,12+8*(i%2),0,Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(-8,8,w,8);
      ctx.restore();
    }

    function drawGround(w,h){
      // Grass bands
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground1');
      ctx.fillRect(0, groundY, w, h-groundY);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground2');
      ctx.fillRect(0, groundY+24, w, h-groundY-24);
      // road stripe
      ctx.fillStyle = 'rgba(255,255,255,.4)';
      for(let x=0;x<w;x+=60){ ctx.fillRect((x - (distance%60)), groundY+12, 30, 4); }
    }

    function drawPlayer(){
      const t = performance.now()/1000;
      // body
      ctx.save();
      ctx.translate(player.x, player.y);
      const squish = player.onGround ? (1 + Math.max(0, Math.sin(t*10)*0.07)) : 1;
      ctx.scale(1, squish);
      const grad = ctx.createRadialGradient(-10,-10,8,0,0,40);
      grad.addColorStop(0, '#fffb7d'); grad.addColorStop(1, '#ff8a00');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(0,0,player.r,0,Math.PI*2); ctx.fill();
      // face
      ctx.translate(0,-4);
      // eyes
      const eyeX = player.onGround ? Math.sin(t*4)*1.5 : 2.5;
      drawEye(-8+eyeX,-6, player.blink>0 ? 0 : 6);
      drawEye(8+eyeX,-6, player.blink>0 ? 0 : 6);
      // mouth
      ctx.fillStyle = '#7a1d3a';
      ctx.beginPath(); ctx.arc(0,6, 8, 0, Math.PI);
      ctx.fill();
      ctx.restore();
      if(player.blink>0) player.blink--; else if(Math.random()<0.005) player.blink=6;
    }
    function drawEye(x,y,r){
      ctx.save(); ctx.translate(x,y);
      if(r<=0){ ctx.fillStyle='#1f2937'; ctx.fillRect(-6,-1,12,2); ctx.restore(); return; }
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0b2038'; ctx.beginPath(); ctx.arc(1,1,r*0.45,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawObstacle(o){
      ctx.save(); ctx.translate(o.x, o.y);
      // goofy block with face
      const g = ctx.createLinearGradient(0, -o.h, 0, 0);
      g.addColorStop(0, '#a78bfa'); g.addColorStop(1, '#7c3aed');
      ctx.fillStyle = g; ctx.strokeStyle = '#4c1d95'; ctx.lineWidth = 3;
      const r=8; ctx.beginPath();
      ctx.moveTo(-o.w/2+r, -o.h);
      ctx.arcTo(o.w/2, -o.h, o.w/2, -o.h+r, r);
      ctx.arcTo(o.w/2, 0, o.w/2-r, 0, r);
      ctx.arcTo(-o.w/2, 0, -o.w/2, -r, r);
      ctx.arcTo(-o.w/2, -o.h, -o.w/2+r, -o.h, r);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      // face
      ctx.translate(0, -o.h+18);
      drawEye(-8,0,4); drawEye(8,0,4);
      ctx.fillStyle='#3b0764'; ctx.fillRect(-6,10,12,3);
      ctx.restore();
    }

    // ---- Game Loop ----
    let last=performance.now();
    function loop(now){
      const dt = Math.min(32, now-last); last=now;
      update(dt/16.6667); // normalize to ~60fps ticks
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      // Parallax movement
      distance += speed*dt;

      // Clouds (slow)
      clouds.forEach(c=>{ c.x -= (speed*0.25 + c.s)*dt; c.y += Math.sin((distance+c.wob)*0.002)*0.05; if(c.x<-120) c.x=w+Math.random()*200; });
      // Hills (mid)
      hills.forEach(o=>{ o.x -= (speed*0.45 + o.s)*dt; if(o.x<-o.r) { o.x=w+o.r+Math.random()*200; o.y=groundY-60-Math.random()*80; o.r= 80+Math.random()*140; }});
      // Bushes (fast)
      bushes.forEach(b=>{ b.x -= (speed*0.9 + b.s)*dt; if(b.x<-80) { b.x=w+Math.random()*200; b.w = 40+Math.random()*50; }});

      if(!running){ return; }

      // Speed ramp
      speed = Math.min(maxSpeed, speed + 0.0009 * dt * (1 + score*0.05));

      // Player physics
      player.vy += G*dt;
      player.y += player.vy*dt;
      const pyFloor = groundY - player.r;
      if(player.y >= pyFloor){ player.y = pyFloor; player.vy = 0; if(!player.onGround){ player.onGround=true; } }

      // Spawn obstacles
      spawnTimer -= dt;
      if(spawnTimer<=0){
        const gap = Math.max(28, 80 - speed*2 - Math.min(24, score*1.2));
        spawnTimer = (gap/10) + (Math.random()*0.8);
        const hgt = 28 + Math.random()*36 + Math.min(28, score*0.8);
        const wid = 30 + Math.random()*22;
        obs.push({ x:w+wid, y: groundY, w: Math.round(wid), h: Math.round(hgt), passed:false });
      }

      // Move obstacles & scoring
      for(let i=obs.length-1;i>=0;i--){
        const o = obs[i];
        o.x -= speed*dt;
        if(!o.passed && o.x + o.w/2 < player.x - player.r){
          o.passed=true; score++; updateHUD(); sfx.score();
        }
        if(o.x < -100){ obs.splice(i,1); }
      }

      // Collision
      for(const o of obs){
        if(circleRectCollision(player.x, player.y, player.r*0.9, o.x-o.w/2, o.y-o.h, o.w, o.h)){
          doGameOver(); break;
        }
      }
    }

    function doGameOver(){
      if(dead) return; dead=true; running=false; sfx.hit();
      if(score>highScore){ highScore=score; localStorage.setItem(HS_KEY, highScore); toast('🏆 NEW BEST!'); }
      updateHUD();
      finalText.innerHTML = `Score: <b>${score}</b> — Best: <b>${highScore}</b><br>Press <b>R</b> or hit <b>Retry</b> to go again!`;
      gameOver.classList.remove('hidden');
    }

    function circleRectCollision(cx, cy, cr, rx, ry, rw, rh){
      // clamp point on rect to circle center
      const nx = Math.max(rx, Math.min(cx, rx+rw));
      const ny = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx-nx, dy = cy-ny; return (dx*dx + dy*dy) <= cr*cr;
    }

    function render(){
      const w = canvas.clientWidth, h = canvas.clientHeight; ctx.clearRect(0,0,w,h);

      // Sky already via CSS bg; add sun
      const sunX = w*0.85, sunY = h*0.18;
      const sg = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 90);
      sg.addColorStop(0,'#fff6b7'); sg.addColorStop(1,'rgba(255,246,183,0)');
      ctx.fillStyle = sg; ctx.beginPath(); ctx.arc(sunX, sunY, 90, 0, Math.PI*2); ctx.fill();

      // Clouds
      clouds.forEach(c=> drawCloud(c.x, c.y, 0.9+c.s*0.6));

      // Hills
      hills.forEach(hh=> drawHill(hh.x, hh.y, hh.r, '#44c152'));

      // Bushes
      bushes.forEach(b=> drawBush(b.x, b.y, b.w));

      // Ground
      drawGround(w,h);

      // Obstacles
      obs.forEach(o=> drawObstacle(o));

      // Player
      drawPlayer();

      // Prompt
      if(!started){
        ctx.fillStyle='rgba(0,0,0,.15)';
        ctx.font='700 18px system-ui';
        ctx.fillText('Press Space / Tap to Start', 16, 28);
      }
    }

  })();
  </script>
</body>
</html>
